// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: model.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_model_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_model_2eproto

#include <limits>
#include <string>


#include <caffe2/core/init.h>
#include <caffe2/core/net.h>
#include <caffe2/utils/proto_utils.h>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "caffe2/proto/caffe2.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_model_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_model_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_model_2eproto;
namespace caffe2 {
class InputInfo;
class InputInfoDefaultTypeInternal;
extern InputInfoDefaultTypeInternal _InputInfo_default_instance_;
class ModelDef;
class ModelDefDefaultTypeInternal;
extern ModelDefDefaultTypeInternal _ModelDef_default_instance_;
class ModelMeta;
class ModelMetaDefaultTypeInternal;
extern ModelMetaDefaultTypeInternal _ModelMeta_default_instance_;
class OutputInfo;
class OutputInfoDefaultTypeInternal;
extern OutputInfoDefaultTypeInternal _OutputInfo_default_instance_;
}  // namespace caffe2
PROTOBUF_NAMESPACE_OPEN
template<> ::caffe2::InputInfo* Arena::CreateMaybeMessage<::caffe2::InputInfo>(Arena*);
template<> ::caffe2::ModelDef* Arena::CreateMaybeMessage<::caffe2::ModelDef>(Arena*);
template<> ::caffe2::ModelMeta* Arena::CreateMaybeMessage<::caffe2::ModelMeta>(Arena*);
template<> ::caffe2::OutputInfo* Arena::CreateMaybeMessage<::caffe2::OutputInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace caffe2 {

// ===================================================================

class InputInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.InputInfo) */ {
 public:
  InputInfo();
  virtual ~InputInfo();

  InputInfo(const InputInfo& from);
  InputInfo(InputInfo&& from) noexcept
    : InputInfo() {
    *this = ::std::move(from);
  }

  inline InputInfo& operator=(const InputInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputInfo& operator=(InputInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InputInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InputInfo* internal_default_instance() {
    return reinterpret_cast<const InputInfo*>(
               &_InputInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InputInfo& a, InputInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(InputInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InputInfo* New() const final {
    return CreateMaybeMessage<InputInfo>(nullptr);
  }

  InputInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InputInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InputInfo& from);
  void MergeFrom(const InputInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.InputInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_2eproto);
    return ::descriptor_table_model_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 1,
  };
  // repeated uint32 dims = 1;
  int dims_size() const;
  private:
  int _internal_dims_size() const;
  public:
  void clear_dims();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_dims() const;
  void _internal_add_dims(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_dims();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 dims(int index) const;
  void set_dims(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_dims(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_dims();

  // @@protoc_insertion_point(class_scope:caffe2.InputInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > dims_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class OutputInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.OutputInfo) */ {
 public:
  OutputInfo();
  virtual ~OutputInfo();

  OutputInfo(const OutputInfo& from);
  OutputInfo(OutputInfo&& from) noexcept
    : OutputInfo() {
    *this = ::std::move(from);
  }

  inline OutputInfo& operator=(const OutputInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutputInfo& operator=(OutputInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OutputInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OutputInfo* internal_default_instance() {
    return reinterpret_cast<const OutputInfo*>(
               &_OutputInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OutputInfo& a, OutputInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OutputInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OutputInfo* New() const final {
    return CreateMaybeMessage<OutputInfo>(nullptr);
  }

  OutputInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OutputInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OutputInfo& from);
  void MergeFrom(const OutputInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutputInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.OutputInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_2eproto);
    return ::descriptor_table_model_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 1,
  };
  // repeated string labels = 1;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  const std::string& labels(int index) const;
  std::string* mutable_labels(int index);
  void set_labels(int index, const std::string& value);
  void set_labels(int index, std::string&& value);
  void set_labels(int index, const char* value);
  void set_labels(int index, const char* value, size_t size);
  std::string* add_labels();
  void add_labels(const std::string& value);
  void add_labels(std::string&& value);
  void add_labels(const char* value);
  void add_labels(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& labels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_labels();
  private:
  const std::string& _internal_labels(int index) const;
  std::string* _internal_add_labels();
  public:

  // @@protoc_insertion_point(class_scope:caffe2.OutputInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> labels_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class ModelMeta :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.ModelMeta) */ {
 public:
  ModelMeta();
  virtual ~ModelMeta();

  ModelMeta(const ModelMeta& from);
  ModelMeta(ModelMeta&& from) noexcept
    : ModelMeta() {
    *this = ::std::move(from);
  }

  inline ModelMeta& operator=(const ModelMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelMeta& operator=(ModelMeta&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelMeta& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelMeta* internal_default_instance() {
    return reinterpret_cast<const ModelMeta*>(
               &_ModelMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ModelMeta& a, ModelMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelMeta* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelMeta* New() const final {
    return CreateMaybeMessage<ModelMeta>(nullptr);
  }

  ModelMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelMeta>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelMeta& from);
  void MergeFrom(const ModelMeta& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelMeta* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.ModelMeta";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_2eproto);
    return ::descriptor_table_model_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 1,
    kOutputFieldNumber = 2,
  };
  // optional .caffe2.InputInfo input = 1;
  bool has_input() const;
  private:
  bool _internal_has_input() const;
  public:
  void clear_input();
  const ::caffe2::InputInfo& input() const;
  ::caffe2::InputInfo* release_input();
  ::caffe2::InputInfo* mutable_input();
  void set_allocated_input(::caffe2::InputInfo* input);
  private:
  const ::caffe2::InputInfo& _internal_input() const;
  ::caffe2::InputInfo* _internal_mutable_input();
  public:

  // optional .caffe2.OutputInfo output = 2;
  bool has_output() const;
  private:
  bool _internal_has_output() const;
  public:
  void clear_output();
  const ::caffe2::OutputInfo& output() const;
  ::caffe2::OutputInfo* release_output();
  ::caffe2::OutputInfo* mutable_output();
  void set_allocated_output(::caffe2::OutputInfo* output);
  private:
  const ::caffe2::OutputInfo& _internal_output() const;
  ::caffe2::OutputInfo* _internal_mutable_output();
  public:

  // @@protoc_insertion_point(class_scope:caffe2.ModelMeta)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::caffe2::InputInfo* input_;
  ::caffe2::OutputInfo* output_;
  friend struct ::TableStruct_model_2eproto;
};
// -------------------------------------------------------------------

class ModelDef :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.ModelDef) */ {
 public:
  ModelDef();
  virtual ~ModelDef();

  ModelDef(const ModelDef& from);
  ModelDef(ModelDef&& from) noexcept
    : ModelDef() {
    *this = ::std::move(from);
  }

  inline ModelDef& operator=(const ModelDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelDef& operator=(ModelDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelDef* internal_default_instance() {
    return reinterpret_cast<const ModelDef*>(
               &_ModelDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ModelDef& a, ModelDef& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelDef* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelDef* New() const final {
    return CreateMaybeMessage<ModelDef>(nullptr);
  }

  ModelDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelDef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelDef& from);
  void MergeFrom(const ModelDef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelDef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.ModelDef";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_model_2eproto);
    return ::descriptor_table_model_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetaFieldNumber = 1,
    kInitFieldNumber = 2,
    kPredictFieldNumber = 3,
  };
  // optional .caffe2.ModelMeta meta = 1;
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::caffe2::ModelMeta& meta() const;
  ::caffe2::ModelMeta* release_meta();
  ::caffe2::ModelMeta* mutable_meta();
  void set_allocated_meta(::caffe2::ModelMeta* meta);
  private:
  const ::caffe2::ModelMeta& _internal_meta() const;
  ::caffe2::ModelMeta* _internal_mutable_meta();
  public:

  // optional .caffe2.NetDef init = 2;
  bool has_init() const;
  private:
  bool _internal_has_init() const;
  public:
  void clear_init();
  const ::caffe2::NetDef& init() const;
  ::caffe2::NetDef* release_init();
  ::caffe2::NetDef* mutable_init();
  void set_allocated_init(::caffe2::NetDef* init);
  private:
  const ::caffe2::NetDef& _internal_init() const;
  ::caffe2::NetDef* _internal_mutable_init();
  public:

  // optional .caffe2.NetDef predict = 3;
  bool has_predict() const;
  private:
  bool _internal_has_predict() const;
  public:
  void clear_predict();
  const ::caffe2::NetDef& predict() const;
  ::caffe2::NetDef* release_predict();
  ::caffe2::NetDef* mutable_predict();
  void set_allocated_predict(::caffe2::NetDef* predict);
  private:
  const ::caffe2::NetDef& _internal_predict() const;
  ::caffe2::NetDef* _internal_mutable_predict();
  public:

  // @@protoc_insertion_point(class_scope:caffe2.ModelDef)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::caffe2::ModelMeta* meta_;
  ::caffe2::NetDef* init_;
  ::caffe2::NetDef* predict_;
  friend struct ::TableStruct_model_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InputInfo

// repeated uint32 dims = 1;
inline int InputInfo::_internal_dims_size() const {
  return dims_.size();
}
inline int InputInfo::dims_size() const {
  return _internal_dims_size();
}
inline void InputInfo::clear_dims() {
  dims_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 InputInfo::_internal_dims(int index) const {
  return dims_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 InputInfo::dims(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.InputInfo.dims)
  return _internal_dims(index);
}
inline void InputInfo::set_dims(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.InputInfo.dims)
}
inline void InputInfo::_internal_add_dims(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  dims_.Add(value);
}
inline void InputInfo::add_dims(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_dims(value);
  // @@protoc_insertion_point(field_add:caffe2.InputInfo.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
InputInfo::_internal_dims() const {
  return dims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
InputInfo::dims() const {
  // @@protoc_insertion_point(field_list:caffe2.InputInfo.dims)
  return _internal_dims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
InputInfo::_internal_mutable_dims() {
  return &dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
InputInfo::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.InputInfo.dims)
  return _internal_mutable_dims();
}

// -------------------------------------------------------------------

// OutputInfo

// repeated string labels = 1;
inline int OutputInfo::_internal_labels_size() const {
  return labels_.size();
}
inline int OutputInfo::labels_size() const {
  return _internal_labels_size();
}
inline void OutputInfo::clear_labels() {
  labels_.Clear();
}
inline std::string* OutputInfo::add_labels() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.OutputInfo.labels)
  return _internal_add_labels();
}
inline const std::string& OutputInfo::_internal_labels(int index) const {
  return labels_.Get(index);
}
inline const std::string& OutputInfo::labels(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.OutputInfo.labels)
  return _internal_labels(index);
}
inline std::string* OutputInfo::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.OutputInfo.labels)
  return labels_.Mutable(index);
}
inline void OutputInfo::set_labels(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.OutputInfo.labels)
  labels_.Mutable(index)->assign(value);
}
inline void OutputInfo::set_labels(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.OutputInfo.labels)
  labels_.Mutable(index)->assign(std::move(value));
}
inline void OutputInfo::set_labels(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.OutputInfo.labels)
}
inline void OutputInfo::set_labels(int index, const char* value, size_t size) {
  labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.OutputInfo.labels)
}
inline std::string* OutputInfo::_internal_add_labels() {
  return labels_.Add();
}
inline void OutputInfo::add_labels(const std::string& value) {
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.OutputInfo.labels)
}
inline void OutputInfo::add_labels(std::string&& value) {
  labels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.OutputInfo.labels)
}
inline void OutputInfo::add_labels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.OutputInfo.labels)
}
inline void OutputInfo::add_labels(const char* value, size_t size) {
  labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.OutputInfo.labels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OutputInfo::labels() const {
  // @@protoc_insertion_point(field_list:caffe2.OutputInfo.labels)
  return labels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OutputInfo::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.OutputInfo.labels)
  return &labels_;
}

// -------------------------------------------------------------------

// ModelMeta

// optional .caffe2.InputInfo input = 1;
inline bool ModelMeta::_internal_has_input() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || input_ != nullptr);
  return value;
}
inline bool ModelMeta::has_input() const {
  return _internal_has_input();
}
inline void ModelMeta::clear_input() {
  if (input_ != nullptr) input_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::caffe2::InputInfo& ModelMeta::_internal_input() const {
  const ::caffe2::InputInfo* p = input_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::InputInfo*>(
      &::caffe2::_InputInfo_default_instance_);
}
inline const ::caffe2::InputInfo& ModelMeta::input() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelMeta.input)
  return _internal_input();
}
inline ::caffe2::InputInfo* ModelMeta::release_input() {
  // @@protoc_insertion_point(field_release:caffe2.ModelMeta.input)
  _has_bits_[0] &= ~0x00000001u;
  ::caffe2::InputInfo* temp = input_;
  input_ = nullptr;
  return temp;
}
inline ::caffe2::InputInfo* ModelMeta::_internal_mutable_input() {
  _has_bits_[0] |= 0x00000001u;
  if (input_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::InputInfo>(GetArenaNoVirtual());
    input_ = p;
  }
  return input_;
}
inline ::caffe2::InputInfo* ModelMeta::mutable_input() {
  // @@protoc_insertion_point(field_mutable:caffe2.ModelMeta.input)
  return _internal_mutable_input();
}
inline void ModelMeta::set_allocated_input(::caffe2::InputInfo* input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete input_;
  }
  if (input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelMeta.input)
}

// optional .caffe2.OutputInfo output = 2;
inline bool ModelMeta::_internal_has_output() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || output_ != nullptr);
  return value;
}
inline bool ModelMeta::has_output() const {
  return _internal_has_output();
}
inline void ModelMeta::clear_output() {
  if (output_ != nullptr) output_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::caffe2::OutputInfo& ModelMeta::_internal_output() const {
  const ::caffe2::OutputInfo* p = output_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::OutputInfo*>(
      &::caffe2::_OutputInfo_default_instance_);
}
inline const ::caffe2::OutputInfo& ModelMeta::output() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelMeta.output)
  return _internal_output();
}
inline ::caffe2::OutputInfo* ModelMeta::release_output() {
  // @@protoc_insertion_point(field_release:caffe2.ModelMeta.output)
  _has_bits_[0] &= ~0x00000002u;
  ::caffe2::OutputInfo* temp = output_;
  output_ = nullptr;
  return temp;
}
inline ::caffe2::OutputInfo* ModelMeta::_internal_mutable_output() {
  _has_bits_[0] |= 0x00000002u;
  if (output_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::OutputInfo>(GetArenaNoVirtual());
    output_ = p;
  }
  return output_;
}
inline ::caffe2::OutputInfo* ModelMeta::mutable_output() {
  // @@protoc_insertion_point(field_mutable:caffe2.ModelMeta.output)
  return _internal_mutable_output();
}
inline void ModelMeta::set_allocated_output(::caffe2::OutputInfo* output) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete output_;
  }
  if (output) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      output = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  output_ = output;
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelMeta.output)
}

// -------------------------------------------------------------------

// ModelDef

// optional .caffe2.ModelMeta meta = 1;
inline bool ModelDef::_internal_has_meta() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || meta_ != nullptr);
  return value;
}
inline bool ModelDef::has_meta() const {
  return _internal_has_meta();
}
inline void ModelDef::clear_meta() {
  if (meta_ != nullptr) meta_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::caffe2::ModelMeta& ModelDef::_internal_meta() const {
  const ::caffe2::ModelMeta* p = meta_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::ModelMeta*>(
      &::caffe2::_ModelMeta_default_instance_);
}
inline const ::caffe2::ModelMeta& ModelDef::meta() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelDef.meta)
  return _internal_meta();
}
inline ::caffe2::ModelMeta* ModelDef::release_meta() {
  // @@protoc_insertion_point(field_release:caffe2.ModelDef.meta)
  _has_bits_[0] &= ~0x00000001u;
  ::caffe2::ModelMeta* temp = meta_;
  meta_ = nullptr;
  return temp;
}
inline ::caffe2::ModelMeta* ModelDef::_internal_mutable_meta() {
  _has_bits_[0] |= 0x00000001u;
  if (meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::ModelMeta>(GetArenaNoVirtual());
    meta_ = p;
  }
  return meta_;
}
inline ::caffe2::ModelMeta* ModelDef::mutable_meta() {
  // @@protoc_insertion_point(field_mutable:caffe2.ModelDef.meta)
  return _internal_mutable_meta();
}
inline void ModelDef::set_allocated_meta(::caffe2::ModelMeta* meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete meta_;
  }
  if (meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meta, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  meta_ = meta;
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelDef.meta)
}

// optional .caffe2.NetDef init = 2;
inline bool ModelDef::_internal_has_init() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || init_ != nullptr);
  return value;
}
inline bool ModelDef::has_init() const {
  return _internal_has_init();
}
inline const ::caffe2::NetDef& ModelDef::_internal_init() const {
  const ::caffe2::NetDef* p = init_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::NetDef*>(
      &::caffe2::_NetDef_default_instance_);
}
inline const ::caffe2::NetDef& ModelDef::init() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelDef.init)
  return _internal_init();
}
inline ::caffe2::NetDef* ModelDef::release_init() {
  // @@protoc_insertion_point(field_release:caffe2.ModelDef.init)
  _has_bits_[0] &= ~0x00000002u;
  ::caffe2::NetDef* temp = init_;
  init_ = nullptr;
  return temp;
}
inline ::caffe2::NetDef* ModelDef::_internal_mutable_init() {
  _has_bits_[0] |= 0x00000002u;
  if (init_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::NetDef>(GetArenaNoVirtual());
    init_ = p;
  }
  return init_;
}
inline ::caffe2::NetDef* ModelDef::mutable_init() {
  // @@protoc_insertion_point(field_mutable:caffe2.ModelDef.init)
  return _internal_mutable_init();
}
inline void ModelDef::set_allocated_init(::caffe2::NetDef* init) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(init_);
  }
  if (init) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      init = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, init, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  init_ = init;
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelDef.init)
}

// optional .caffe2.NetDef predict = 3;
inline bool ModelDef::_internal_has_predict() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || predict_ != nullptr);
  return value;
}
inline bool ModelDef::has_predict() const {
  return _internal_has_predict();
}
inline const ::caffe2::NetDef& ModelDef::_internal_predict() const {
  const ::caffe2::NetDef* p = predict_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::NetDef*>(
      &::caffe2::_NetDef_default_instance_);
}
inline const ::caffe2::NetDef& ModelDef::predict() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelDef.predict)
  return _internal_predict();
}
inline ::caffe2::NetDef* ModelDef::release_predict() {
  // @@protoc_insertion_point(field_release:caffe2.ModelDef.predict)
  _has_bits_[0] &= ~0x00000004u;
  ::caffe2::NetDef* temp = predict_;
  predict_ = nullptr;
  return temp;
}
inline ::caffe2::NetDef* ModelDef::_internal_mutable_predict() {
  _has_bits_[0] |= 0x00000004u;
  if (predict_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::NetDef>(GetArenaNoVirtual());
    predict_ = p;
  }
  return predict_;
}
inline ::caffe2::NetDef* ModelDef::mutable_predict() {
  // @@protoc_insertion_point(field_mutable:caffe2.ModelDef.predict)
  return _internal_mutable_predict();
}
inline void ModelDef::set_allocated_predict(::caffe2::NetDef* predict) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(predict_);
  }
  if (predict) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      predict = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, predict, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  predict_ = predict;
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelDef.predict)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace caffe2

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_model_2eproto
